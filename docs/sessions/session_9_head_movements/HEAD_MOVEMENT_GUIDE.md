# üé≠ Guide Technique : Mouvements de T√™te Automatiques

## üìã Vue d'ensemble

Ce guide d√©taille l'**impl√©mentation technique des mouvements de t√™te automatiques** dans Desktop-Mate.

**Objectif :** Rendre l'avatar plus vivant avec des mouvements de t√™te **al√©atoires, naturels et fluides**.

---

## üèóÔ∏è Architecture

### Composants

```
Python GUI (app.py)
    ‚Üì Checkbox + Sliders
Python IPC (unity_bridge.py)
    ‚Üì JSON command
Unity PythonBridge (PythonBridge.cs)
    ‚Üì Parse & call
Unity Controller (VRMHeadMovementController.cs)
    ‚Üì Coroutine
VRM Head Bone
    ‚Üì Rotation update
Avatar visuel
```

---

## üéØ Unity C# : VRMHeadMovementController

### Fichier

`unity/VRMHeadMovementController.cs`

### Classe compl√®te

```csharp
using System.Collections;
using UnityEngine;

public class VRMHeadMovementController : MonoBehaviour
{
    [Header("Head Movement Settings")]
    [Tooltip("Enable/disable automatic head movements")]
    public bool enabled = true;

    [Tooltip("Minimum interval between movements (seconds)")]
    [Range(1f, 5f)]
    public float minInterval = 3f;

    [Tooltip("Maximum interval between movements (seconds)")]
    [Range(3f, 15f)]
    public float maxInterval = 7f;

    [Tooltip("Maximum rotation angle (degrees)")]
    [Range(1f, 20f)]
    public float maxAngle = 5f;

    private Transform headBone;
    private Quaternion initialHeadRotation;
    private Coroutine movementCoroutine;

    void Start()
    {
        // Find head bone via Animator
        Animator animator = GetComponent<Animator>();
        if (animator != null)
        {
            headBone = animator.GetBoneTransform(HumanBodyBones.Head);
            if (headBone != null)
            {
                initialHeadRotation = headBone.localRotation;
                Debug.Log($"[VRMHeadMovementController] Head bone found: {headBone.name}");
                
                if (enabled)
                {
                    StartMovements();
                }
            }
            else
            {
                Debug.LogError("[VRMHeadMovementController] Head bone not found!");
            }
        }
        else
        {
            Debug.LogError("[VRMHeadMovementController] Animator not found!");
        }
    }

    public void SetEnabled(bool value)
    {
        enabled = value;
        if (enabled)
        {
            StartMovements();
        }
        else
        {
            StopMovements();
        }
    }

    public void SetParameters(float minInt, float maxInt, float angle)
    {
        minInterval = Mathf.Clamp(minInt, 1f, 5f);
        maxInterval = Mathf.Clamp(maxInt, 3f, 15f);
        maxAngle = Mathf.Clamp(angle, 1f, 20f);
        
        Debug.Log($"[VRMHeadMovementController] Parameters updated: min={minInterval}s, max={maxInterval}s, angle={maxAngle}¬∞");
    }

    private void StartMovements()
    {
        if (headBone == null) return;
        
        if (movementCoroutine != null)
        {
            StopCoroutine(movementCoroutine);
        }
        
        movementCoroutine = StartCoroutine(RandomHeadMovement());
        Debug.Log("[VRMHeadMovementController] Head movements started");
    }

    private void StopMovements()
    {
        if (movementCoroutine != null)
        {
            StopCoroutine(movementCoroutine);
            movementCoroutine = null;
        }
        
        if (headBone != null)
        {
            headBone.localRotation = initialHeadRotation;
        }
        
        Debug.Log("[VRMHeadMovementController] Head movements stopped");
    }

    private IEnumerator RandomHeadMovement()
    {
        while (enabled)
        {
            // Wait random interval
            float waitTime = Random.Range(minInterval, maxInterval);
            yield return new WaitForSeconds(waitTime);

            // Generate random target rotation
            float targetYaw = Random.Range(-maxAngle, maxAngle);
            float targetPitch = Random.Range(-maxAngle / 2f, maxAngle / 2f);

            Quaternion startRotation = headBone.localRotation;
            Quaternion targetRotation = initialHeadRotation * 
                Quaternion.Euler(targetPitch, targetYaw, 0f);

            // Smooth interpolation
            float movementDuration = Random.Range(0.3f, 0.8f);
            float elapsedTime = 0f;

            while (elapsedTime < movementDuration)
            {
                elapsedTime += Time.deltaTime;
                float t = elapsedTime / movementDuration;
                float smoothT = Mathf.SmoothStep(0f, 1f, t);

                headBone.localRotation = Quaternion.Slerp(
                    startRotation,
                    targetRotation,
                    smoothT
                );

                yield return null;
            }

            // Hold position briefly
            yield return new WaitForSeconds(Random.Range(0.2f, 0.5f));

            // Return to neutral
            startRotation = headBone.localRotation;
            elapsedTime = 0f;
            movementDuration = Random.Range(0.4f, 0.9f);

            while (elapsedTime < movementDuration)
            {
                elapsedTime += Time.deltaTime;
                float t = elapsedTime / movementDuration;
                float smoothT = Mathf.SmoothStep(0f, 1f, t);

                headBone.localRotation = Quaternion.Slerp(
                    startRotation,
                    initialHeadRotation,
                    smoothT
                );

                yield return null;
            }

            headBone.localRotation = initialHeadRotation;
        }
    }

    void OnDisable()
    {
        StopMovements();
    }
}
```

### Explication d√©taill√©e

#### 1. Recherche du head bone

```csharp
Animator animator = GetComponent<Animator>();
headBone = animator.GetBoneTransform(HumanBodyBones.Head);
initialHeadRotation = headBone.localRotation;
```

**Pourquoi :**
- Les mod√®les VRM utilisent le syst√®me Humanoid d'Unity
- `HumanBodyBones.Head` est l'enum standard pour la t√™te
- On sauvegarde la rotation initiale pour y revenir (position neutre)

**Alternatives :**
- ‚ùå Rechercher par nom ("Head", "head", "È†≠") ‚Üí Fragile, d√©pend du mod√®le
- ‚úÖ Utiliser Humanoid ‚Üí Fonctionne avec tous les VRM

#### 2. G√©n√©ration angles al√©atoires

```csharp
float targetYaw = Random.Range(-maxAngle, maxAngle);      // Gauche/Droite
float targetPitch = Random.Range(-maxAngle / 2f, maxAngle / 2f);  // Haut/Bas
```

**Explication :**
- **Yaw** (Y-axis) : Rotation horizontale (-5¬∞ √† +5¬∞ par d√©faut)
- **Pitch** (X-axis) : Rotation verticale (moiti√© moins, -2.5¬∞ √† +2.5¬∞)
- **Roll** (Z-axis) : Pas utilis√© (√©vite l'effet "pench√© bizarre")

**Pourquoi pitch/2 ?**
- Mouvements verticaux trop amples = bizarre (penche trop la t√™te)
- Mouvements horizontaux plus naturels et fr√©quents

#### 3. Interpolation SmoothStep

```csharp
float t = elapsedTime / movementDuration;
float smoothT = Mathf.SmoothStep(0f, 1f, t);

headBone.localRotation = Quaternion.Slerp(
    startRotation,
    targetRotation,
    smoothT
);
```

**SmoothStep vs Lerp :**

| M√©thode | Courbe | Vitesse | Naturalit√© |
|---------|--------|---------|-----------|
| `Lerp` | Lin√©aire | Constante | Robotique ‚ùå |
| `SmoothStep` | S-curve | Variable | Naturelle ‚úÖ |

**Visualisation SmoothStep :**
```
Vitesse
  ^
  ‚îÇ     ‚ï±‚îÄ‚îÄ‚îÄ‚îÄ‚ï≤
  ‚îÇ    ‚ï±      ‚ï≤
  ‚îÇ   ‚ï±        ‚ï≤
  ‚îÇ  ‚ï±          ‚ï≤
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> Temps
    Acc√©l√©ration | D√©c√©l√©ration
```

**R√©sultat :**
- D√©marrage progressif (pas de "jerk")
- Acc√©l√©ration au milieu
- Arr√™t en douceur

#### 4. Cycle de mouvement

```
1. Attendre (minInterval √† maxInterval)
   ‚Üì
2. G√©n√©rer rotation al√©atoire (yaw + pitch)
   ‚Üì
3. Interpoler vers target (0.3-0.8s)
   ‚Üì
4. Tenir position (0.2-0.5s)
   ‚Üì
5. Retourner √† neutre (0.4-0.9s)
   ‚Üì
6. R√©p√©ter
```

**Dur√©es al√©atoires :**
- Mouvement vers target : 0.3-0.8s
- Hold position : 0.2-0.5s  
- Retour neutre : 0.4-0.9s

**Pourquoi ?** √âviter la pr√©visibilit√©, rendre naturel.

---

## üîå Unity IPC : PythonBridge

### Commande `set_auto_head_movement`

**Ajout dans PythonBridge.cs :**

```csharp
case "set_auto_head_movement":
{
    bool enabled = data.ContainsKey("enabled") && (bool)data["enabled"];
    float minInterval = data.ContainsKey("min_interval") ? 
        Convert.ToSingle(data["min_interval"]) : 3f;
    float maxInterval = data.ContainsKey("max_interval") ? 
        Convert.ToSingle(data["max_interval"]) : 7f;
    float maxAngle = data.ContainsKey("max_angle") ? 
        Convert.ToSingle(data["max_angle"]) : 5f;

    if (headMovementController != null)
    {
        headMovementController.SetEnabled(enabled);
        if (enabled)
        {
            headMovementController.SetParameters(minInterval, maxInterval, maxAngle);
        }
        Debug.Log($"[PythonBridge] Auto head movement: {enabled}, " +
                  $"interval=[{minInterval}-{maxInterval}]s, angle={maxAngle}¬∞");
    }
    break;
}
```

**Gestion des param√®tres :**
- `enabled` : true/false
- `min_interval` : 3.0s (fixe depuis Python)
- `max_interval` : 3.0-10.0s (slider Python)
- `max_angle` : 2.0-10.0¬∞ (slider Python)

---

## üêç Python : unity_bridge.py

### M√©thode d'envoi

```python
def set_auto_head_movement(self, enabled: bool, min_interval: float, 
                           max_interval: float, max_angle: float):
    """Enable/disable automatic head movements with parameters.
    
    Args:
        enabled: Enable or disable head movements
        min_interval: Minimum interval between movements (seconds)
        max_interval: Maximum interval between movements (seconds)
        max_angle: Maximum rotation angle (degrees)
    """
    command = {
        "command": "set_auto_head_movement",
        "enabled": enabled,
        "min_interval": min_interval,
        "max_interval": max_interval,
        "max_angle": max_angle
    }
    self.send_command("set_auto_head_movement", command)
    logger.info(f"Set auto head movement: {enabled}, "
                f"interval=[{min_interval}-{max_interval}]s, "
                f"angle={max_angle}¬∞")
```

### Exemple JSON envoy√©

```json
{
  "command": "set_auto_head_movement",
  "enabled": true,
  "min_interval": 3.0,
  "max_interval": 7.0,
  "max_angle": 5.0
}
```

---

## üñ•Ô∏è Python : Interface GUI

### Sliders dans app.py

**Fr√©quence (max_interval) :**
```python
self.head_freq_slider = QSlider(Qt.Horizontal)
self.head_freq_slider.setMinimum(30)   # 3.0s
self.head_freq_slider.setMaximum(100)  # 10.0s
self.head_freq_slider.setValue(70)     # 7.0s default

# Conversion: slider_value / 10.0 = seconds
max_interval = self.head_freq_slider.value() / 10.0
```

**Amplitude (max_angle) :**
```python
self.head_amp_slider = QSlider(Qt.Horizontal)
self.head_amp_slider.setMinimum(20)   # 2.0¬∞
self.head_amp_slider.setMaximum(100)  # 10.0¬∞
self.head_amp_slider.setValue(50)     # 5.0¬∞ default

# Conversion: slider_value / 10.0 = degrees
max_angle = self.head_amp_slider.value() / 10.0
```

### Handler de changement

```python
def on_head_movement_param_change(self, label, format_str, value, param_name):
    """Handle head movement parameter slider change."""
    # Update label
    label.setText(format_str.format(value))
    
    # Save to config
    self.config.set(f"avatar.auto_head_movement.{param_name}", value)
    self.config.save()
    
    # Send to Unity if enabled
    if self.unity_bridge.is_connected() and self.vrm_loaded:
        if self.auto_head_movement_checkbox.isChecked():
            min_interval = 3.0
            max_interval = self.head_freq_slider.value() / 10.0
            max_angle = self.head_amp_slider.value() / 10.0
            
            self.unity_bridge.set_auto_head_movement(
                True, min_interval, max_interval, max_angle
            )
```

---

## üìä Param√®tres et valeurs

### Tableau r√©capitulatif

| Param√®tre | Type | Min | Max | D√©faut | Unit√© | Description |
|-----------|------|-----|-----|--------|-------|-------------|
| `enabled` | bool | - | - | `true` | - | Active/d√©sactive mouvements |
| `min_interval` | float | 1.0 | 5.0 | `3.0` | secondes | Intervalle minimum (fixe) |
| `max_interval` | float | 3.0 | 15.0 | `7.0` | secondes | Intervalle maximum (slider) |
| `max_angle` | float | 1.0 | 20.0 | `5.0` | degr√©s | Angle maximum rotation |

### Comportement selon les valeurs

**Fr√©quence (max_interval) :**
- `3.0s` ‚Üí Mouvements fr√©quents (toutes les 3s)
- `7.0s` ‚Üí Mouvements mod√©r√©s (tous les 3-7s) ‚úÖ D√©faut
- `10.0s` ‚Üí Mouvements rares (tous les 3-10s)

**Amplitude (max_angle) :**
- `2.0¬∞` ‚Üí Mouvements subtils (micro-mouvements)
- `5.0¬∞` ‚Üí Mouvements naturels ‚úÖ D√©faut
- `10.0¬∞` ‚Üí Mouvements amples (tr√®s expressifs)

---

## üß™ Tests et validation

### Tests fonctionnels

**Test 1 : Activation/D√©sactivation**
```
1. Charger VRM
2. Cocher "Activer mouvements de t√™te"
   ‚Üí Mouvements d√©marrent
3. D√©cocher
   ‚Üí Mouvements s'arr√™tent, t√™te revient √† neutre
```

**Test 2 : Fr√©quence**
```
1. Slider √† 3.0s (min)
   ‚Üí Mouvements tr√®s fr√©quents
2. Slider √† 10.0s (max)
   ‚Üí Mouvements rares
```

**Test 3 : Amplitude**
```
1. Slider √† 2.0¬∞ (min)
   ‚Üí Micro-mouvements subtils
2. Slider √† 10.0¬∞ (max)
   ‚Üí Grands mouvements expressifs
```

### Tests de performance

**M√©triques :**
- ‚úÖ FPS stable (60 FPS maintenu)
- ‚úÖ Pas de lag visible
- ‚úÖ Coroutine n'impacte pas Update()

**Monitoring Unity :**
```csharp
// Profiler ‚Üí CPU Usage ‚Üí VRMHeadMovementController
// Overhead : < 0.1ms par frame
```

### Tests edge cases

**Test 1 : D√©connexion Unity**
```
1. Activer mouvements
2. Fermer Unity
   ‚Üí Python d√©tecte d√©connexion
   ‚Üí UI se d√©sactive correctement
```

**Test 2 : Mod√®le sans head bone**
```
1. Charger mod√®le non-Humanoid
   ‚Üí Log erreur "Head bone not found"
   ‚Üí Pas de crash, comportement graceful
```

**Test 3 : Valeurs extr√™mes**
```
1. Slider fr√©quence √† 3.0s, amplitude √† 2.0¬∞
   ‚Üí Mouvements subtils mais visibles
2. Slider fr√©quence √† 10.0s, amplitude √† 10.0¬∞
   ‚Üí Mouvements rares mais amples
```

---

## üé® Variantes et am√©liorations futures

### Variante 1 : Mouvements influenc√©s par l'audio

```csharp
// Dans RandomHeadMovement()
if (AudioAnalyzer.IsSpeaking())
{
    // Mouvements plus fr√©quents pendant la parole
    waitTime = Random.Range(minInterval * 0.5f, maxInterval * 0.5f);
}
```

### Variante 2 : Regard vers le curseur

```csharp
// Calculer direction vers curseur souris
Vector3 cursorWorldPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);
Vector3 directionToCursor = (cursorWorldPos - headBone.position).normalized;

// Limiter rotation vers curseur
Quaternion lookRotation = Quaternion.LookRotation(directionToCursor);
headBone.rotation = Quaternion.Slerp(
    headBone.rotation,
    lookRotation,
    Time.deltaTime * lookSpeed
);
```

### Variante 3 : Profils √©motionnels

```csharp
enum EmotionalState { Calm, Excited, Sad }

EmotionalState currentEmotion = EmotionalState.Calm;

switch (currentEmotion)
{
    case EmotionalState.Excited:
        minInterval *= 0.5f;  // Mouvements plus fr√©quents
        maxAngle *= 1.5f;     // Plus amples
        break;
    case EmotionalState.Sad:
        minInterval *= 2f;    // Mouvements plus rares
        maxAngle *= 0.5f;     // Plus subtils
        break;
}
```

---

## üîß Debugging

### Logs Unity

**Activation :**
```
[VRMHeadMovementController] Head bone found: J_Bip_C_Head
[VRMHeadMovementController] Head movements started
```

**Mise √† jour param√®tres :**
```
[VRMHeadMovementController] Parameters updated: min=3s, max=7s, angle=5¬∞
[PythonBridge] Auto head movement: True, interval=[3-7]s, angle=5¬∞
```

**D√©sactivation :**
```
[VRMHeadMovementController] Head movements stopped
```

### Probl√®mes courants

**Probl√®me 1 : Pas de mouvement**

V√©rifier :
- [ ] Head bone trouv√© ? (Log "Head bone found")
- [ ] Enabled = true ?
- [ ] VRM charg√© ?
- [ ] Script attach√© au bon GameObject ?

**Probl√®me 2 : Mouvements saccad√©s**

Solution :
- Utiliser `SmoothStep` au lieu de `Lerp`
- Augmenter `movementDuration` (0.5-1.0s)
- V√©rifier FPS stable

**Probl√®me 3 : Rotation bizarre (t√™te pench√©)**

Cause : Utilisation de rotation absolute au lieu de locale

Solution :
```csharp
// ‚úÖ CORRECT
headBone.localRotation = targetRotation;

// ‚ùå INCORRECT
headBone.rotation = targetRotation;
```

---

## üìö Ressources

### Unity Documentation

- [Humanoid Avatars](https://docs.unity3d.com/Manual/ConfiguringtheAvatar.html)
- [Quaternion.Slerp](https://docs.unity3d.com/ScriptReference/Quaternion.Slerp.html)
- [Mathf.SmoothStep](https://docs.unity3d.com/ScriptReference/Mathf.SmoothStep.html)
- [Coroutines](https://docs.unity3d.com/Manual/Coroutines.html)

### UniVRM Documentation

- [VRM Specification](https://github.com/vrm-c/vrm-specification)
- [UniVRM GitHub](https://github.com/vrm-c/UniVRM)

---

## ‚úÖ Checklist d'impl√©mentation

Pour impl√©menter des mouvements similaires :

### Unity
- [ ] Cr√©er VRMHeadMovementController.cs
- [ ] Attacher au GameObject avec Animator
- [ ] Configurer param√®tres dans Inspector
- [ ] Tester mouvements visuellement

### IPC
- [ ] Ajouter commande dans PythonBridge.cs
- [ ] Extraire param√®tres JSON
- [ ] Appeler SetEnabled() et SetParameters()

### Python
- [ ] Cr√©er m√©thode unity_bridge.set_auto_head_movement()
- [ ] Ajouter UI (checkbox + sliders)
- [ ] Connecter signaux
- [ ] Sauvegarder config

### Tests
- [ ] Test activation/d√©sactivation
- [ ] Test sliders (min/max)
- [ ] Test performance (FPS)
- [ ] Test d√©connexion Unity

---

**Fichier :** `docs/sessions/session_9_head_movements/HEAD_MOVEMENT_GUIDE.md`  
**Date :** Octobre 2025  
**Auteur :** Copilot + Utilisateur
